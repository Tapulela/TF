--V1.4:
--	Ahora la bascula es una variante mas de equipamiento.
--	Los equipamientos referencian una bascula.
--	Agregada restriccion de chequeo de idBascula en Movimientos internos de Materia prima: Se verifica que se referencia a un equipamiento de tipo bascula.
--	Agregado a ordenes de compra informacion de la cantidad a comprar, costo por unidad y unidad de medida.
--	Agregado fecha de Origen a la tabla de Movimientos.
-- 	Agregado estado a Movimiento. Puede ser:
--		Listo para Transformarse: Lo que se registro en este movimiento es para una transformacion en el equipamiento asociado.
--		Utilizado: Ya se registro una transformacion sobre ese movimiento
--		De Almacenamiento temporal: Lo que se registro en este movimiento no sera utilizado en este equipamiento. Será trasladado posteriormente.
--		Trasladado: El almacenamiento temporal terminó y ese lote fue trasladado.
--	Agregado etiquetas a los lotes
--v1.6
--	Removido la clave foranea de lote padre de los lotes.
--v1.7
--	Removido la clave foranea de Orden de compra con lotes
--	Agregado la clave foranea de lotes hacia orden de compra.
--	Agregado la clave foranea de lotes hacia Equipamiento. (Un lote esta en un momento dado en un equipamiento)
--	CAMBIADO CUIL POR CUIT en proveedores
--	Ahora tambien es un campo unico la razon social en proveedores
--	Agregado campo de descripcion a las ordenes de producción.

--v1.8
--	REMOCION DE TODAS LAS CLAVES FORANEAS REDUNDANTES.
--	En la base de datos: La menor cantidad de referencias posibles.
--	En la aplicación: La mayor cantidad de referencias posibles.
--	Removido clave foranea de lote hacia orden de produccion
-- 	Removido clave foranea de lote hacia equipamiento. (El lote reside en el equipamiento sobre el que equipamiento destino del ultimo movimiento registrado.

--v1.9
--	Agregado de tablas de Pais provincia y Localidad
--	Agregado referencia de proveedor a localidad

--v1.10
--	Adicion de ROLES
--	Agregado proveedor de servicio de transporte a movimientos
-- 	Agregado de secuencia de evento para numerar la ocurrencia de
--		Ordenes de produccion
--		Ordenes de Compra
--		Movimientos
--		Posiblemente transformaciones
--	Tengo que agregar una referencia a usuarios en ordenes de produccion y de compra.

--PRIMERO SE DEBEN ELIMINAR TODOS LOS USUARIOS

DELETE FROM MOVIMIENTOS_INTERNOS_MP;
DELETE FROM ORDENES_COMPRA;
DELETE FROM ORDENES_PRODUCCION;
DELETE from usuarios;
DELETE from usuarios;
--Borrar toda la base de datos, para luego poder realizar todas las definiciones con los contadores incrementales en 0.
DROP SCHEMA public CASCADE;
CREATE SCHEMA public;


--CREAR SECUENCIA DE EVENTOS.

	
CREATE SEQUENCE evento_id_seq;
 
/*CREATE TABLE table_name (
    ID_Evento integer NOT NULL DEFAULT nextval('evento_id_seq')
);*/--EJEMPLO PARA AGREGAR A UNA TABLA LA COLUMNA CON EL SECUENCIADOR
 
ALTER SEQUENCE evento_id_seq
OWNED BY NONE;

--ESTABLECER EL FORMATO DD/MM/AAAA:
SET DATESTYLE TO 'European';

--ROLES


	
--AGREGADO DEL ROL AL QUE PERTENECE CADA USUARIO

--FUNCION DE CONVERSION DE UNIDADES DE MEDIDA

--Conversion de Peso
CREATE OR REPLACE FUNCTION convertirUnidadPeso(unidad_De_Medida_Inicial varchar(30), unidad_De_Medida_Final varchar(30), peso float) returns float as
$BODY$
BEGIN
	CASE
		When (unidad_De_Medida_Inicial='Tonelada') AND (unidad_De_Medida_Final = 'Kilogramo') THEN	
			RETURN peso*1000;
		When (unidad_De_Medida_Inicial='Kilogramo') AND (unidad_De_Medida_Final = 'Tonelada') THEN	
			RETURN peso/1000;
		ELSE
			RETURN peso;
	END CASE;
END;
$BODY$
language plpgsql;


--CREAR LAS TABLAS

create table USUARIOS (
	ID SERIAL, 
	Nombre_Usuario varchar(100),
	Nombre varchar(100) NOT NULL,
	Apellido varchar(100) NOT NULL,
	DNI varchar(100) UNIQUE NOT NULL,
	Estado varchar(30) NOT NULL,
	Rol varchar(100),
	primary key(ID));
	
alter table USUARIOS add column rol_asociado oid;

create table PAISES (
	ID SERIAL, 
	Nombre varchar(100) UNIQUE NOT NULL,
	Estado varchar(30) NOT NULL,
	primary key(ID));

create table PROVINCIAS (
	ID SERIAL, 
	Nombre varchar(100) NOT NULL,
	Estado varchar(30) NOT NULL,
	primary key(ID));
	
create table LOCALIDADES (
	ID SERIAL, 
	Nombre varchar(100) NOT NULL,
	Codigo_Postal varchar(10) NOT NULL,
	Estado varchar(30) NOT NULL,
	primary key(ID));	

create table ORDENES_PRODUCCION (
	ID SERIAL, 
	ID_Evento integer NOT NULL DEFAULT nextval('evento_id_seq'),
	Cantidad_A_Producir float, 
	Unidad_De_Medida varchar(30), 
	Fecha_Origen date, 
	Fecha_Entrega date, 
	Estado varchar(30),
	Descripcion varchar(250),
	primary key(ID));

create table ORDENES_COMPRA (
	ID SERIAL,
	ID_Evento integer NOT NULL DEFAULT nextval('evento_id_seq'),
	Fecha_Origen date NOT NULL,
	Cantidad float NOT NULL,
	Unidad_De_Medida varchar(30) NOT NULL,
	Costo_De_Compra_PorUnidad float NOT NULL,
	Estado varchar(30) NOT NULL,
	primary key(ID));

create table PROVEEDORES (
	ID SERIAL,
	Razon_Social varchar(60), 
	CUIT varchar(30) NOT NULL, 
	Estado varchar(30) NOT NULL, 
	primary key (ID), 
	UNIQUE(CUIT),
	UNIQUE(Razon_Social));

create table LOTES (
	ID SERIAL,
	Tipo_Lote varchar(60) NOT NULL,
	Etiqueta varchar(60),
	Estado varchar(30),
	Cantidad int,
	Unidad_De_Medida varchar(30),
	Fecha_Adquisicion date,
	primary key(ID));

create table MOVIMIENTOS_INTERNOS_MP(
	ID SERIAL,
	ID_Evento integer NOT NULL DEFAULT nextval('evento_id_seq'),
	Fecha_Origen date NOT NULL,
	Hora_Entrada TIMESTAMPTZ NOT NULL,
	Hora_Salida TIMESTAMPTZ NOT NULL,
	Tipo_Unidad_Transporte varchar(60) NOT NULL,
	cantidad_Unidades int NOT NULL,
	Unidad_De_Medida_Peso varchar(30) NOT NULL,
	Peso_Entrada float NOT NULL,
	Peso_Salida float NOT NULL,
	N_Hoja_Ruta varchar(50) NOT NULL,
	N_Remito varchar(50) NOT NULL,
	N_Precinto varchar(50) NOT NULL,
	Nombre_Conductor varchar(100) NOT NULL,
	Patente_Chasis varchar(30) NOT NULL,
	Patente_Acoplado varchar(30) NOT NULL,

	Estado varchar(30) NOT NULL,
	primary key(ID));


create table EQUIPAMIENTOS (
	ID SERIAL,
	Nombre varchar(60) UNIQUE NOT NULL,
	Tipo_Equipamiento varchar(60) NOT NULL,
	Direccion varchar(60) NOT NULL,
	Fecha_Adquisicion date NOT NULL,
	Fecha_Ultimo_Mantenimiento date,
	Capacidad_Maxima float NOT NULL,
	Unidad_De_Medida varchar(30) NOT NULL,
	Duracion_Maxima_Estacionamiento float,
	Estado varchar(30),
	primary key(ID));

--INSERCION CLAVES FORANEAS

--PAIS, PROVINCIA Y LOCALIDAD

alter table PROVINCIAS add column IdPais int NOT NULL;
alter table public.PROVINCIAS add constraint FK_PAISES_ID foreign key (IdPais) references PAISES(ID) on update cascade;

 alter table PROVINCIAS
   add constraint UQ_PROVINCIA_PAIS
   unique (Nombre, IdPais);

alter table LOCALIDADES add column IdProvincia int NOT NULL;
alter table public.LOCALIDADES add constraint FK_PROVINCIAS_ID foreign key (IdProvincia) references PROVINCIAS(ID) on update cascade;

 alter table LOCALIDADES
   add constraint UQ_LOCALIDAD_PROVINCIA
   unique (Nombre, IdProvincia);
--PROVEEDORES

alter table PROVEEDORES add column IdLocalidad int NOT NULL;
alter table public.PROVEEDORES add constraint FK_LOCALIDADES_ID foreign key (IdLocalidad) references LOCALIDADES(ID) on update cascade;

--ORDENES DE PRODUCCION
alter table ORDENES_PRODUCCION add column IdUsuario int NOT NULL;
alter table public.ORDENES_PRODUCCION add constraint FK_USUARIOS_ID foreign key (IdUsuario) references USUARIOS(ID) on update cascade on delete cascade;


--ORDENES DE COMPRA


--alter table ORDENES_COMPRA add column IdLote int NOT NULL; --DEBERIA SER UNIQUE?
--alter table public.ORDENES_COMPRA add constraint FK_LOTES_ID foreign key (IdLote) references LOTES(ID) on update cascade;

alter table ORDENES_COMPRA add column IdProveedor int;
alter table public.ORDENES_COMPRA add constraint FK_PROVEEDORES_ID foreign key (IdProveedor) references PROVEEDORES(ID) on update cascade;

alter table ORDENES_COMPRA add column IdOrdenProduccion int NOT NULL;
alter table public.ORDENES_COMPRA add constraint FK_ORDENES_PRODUCCION_ID foreign key (IdOrdenProduccion) references ORDENES_PRODUCCION(ID) on update cascade;

alter table ORDENES_COMPRA add column IdUsuario int NOT NULL;
alter table public.ORDENES_COMPRA add constraint FK_USUARIOS_ID foreign key (IdUsuario) references USUARIOS(ID) on update cascade on delete cascade;

--LOTES


alter table LOTES add column IdOrdenCompra int NOT NULL; --NO PUEDE SER NULL.
alter table public.LOTES add constraint FK_ORDENES_COMPRA_ID foreign key (IdOrdenCompra) references ORDENES_COMPRA(ID) on update cascade;

alter table LOTES add column IdEquipamiento int; --NO PUEDE SER NULL.
alter table public.LOTES add constraint FK_EQUIPAMIENTO_RESIDENCIA_ID foreign key (IdEquipamiento) references EQUIPAMIENTOS(ID) on update cascade on delete cascade;


/*alter table LOTES add column IdMovimientoInternoMpIngreso int; --PUEDE Y DEBE SER NULL PARA PODER DAR DE ALTA EL LOTE, GENERAR SU ETIQUETA Y LUEGO GENERAR EL MOVIMIENTO PARA LUEGO VINCULARLO.
alter table public.LOTES add constraint FK_PRIMERO_MOVIMIENTO_ID foreign key (IdMovimientoInternoMpIngreso) references MOVIMIENTOS_INTERNOS_MP(ID) on update cascade;

alter table LOTES add column IdMovimientoInternoMpUltimo int; --ES EL ULTIMO MOVIMIENTO. DEBE SER NULL POR EL MISMO MOTIVO DESCRITO EN EL MOVIMIENTO DE INGRESO.
alter table public.LOTES add constraint FK_ULTIMO_MOVIMIENTO_ID foreign key (IdMovimientoInternoMpUltimo) references MOVIMIENTOS_INTERNOS_MP(ID) on update cascade;*/

--POR MOTIVOS DE REFERENCIA BIDIRECCIONAL, NO PUEDO UTILIZAR ESTAS CLAVES FORANEAS EN JAVA. (YA QUE RECUPERO PRIMERO TODOS LOS LOTES Y POSTERIORMENTE LOS MOVIMIENTOS)
--POR ELLO SI EVENTUALMENTE REQUIERO ELIMINAR ESTAS LLAVES FORANEAS SOY LIBRE DE HACERLO. LAS DEJO PORQUE EN LA BD PUEDE SER UTIL
--MOVIMIENTOS_INTERNOS_MP

alter table MOVIMIENTOS_INTERNOS_MP add column IdUsuario int;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_USUARIOS_ID foreign key (IdUsuario) references USUARIOS(ID) on update cascade on delete cascade;

alter table MOVIMIENTOS_INTERNOS_MP add column IdLote int NOT NULL;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_LOTES_ID foreign key (IdLote) references LOTES(ID) on update cascade;

alter table MOVIMIENTOS_INTERNOS_MP add column IdBascula int NOT NULL;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_BASCULAS_ID foreign key (IdBascula) references EQUIPAMIENTOS(ID) on update cascade;

alter table MOVIMIENTOS_INTERNOS_MP add column IdProveedorTransporte int NOT NULL;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_PROVEEDORES_ID foreign key (IdProveedorTransporte) references PROVEEDORES(ID) on update cascade;

alter table MOVIMIENTOS_INTERNOS_MP add column IdEquipamientoOrigen int;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_ORIGEN_ID foreign key (IdEquipamientoOrigen) references EQUIPAMIENTOS(ID) on update cascade;

alter table MOVIMIENTOS_INTERNOS_MP add column IdEquipamientoDestino int;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_DESTINO_ID foreign key (IdEquipamientoDestino) references EQUIPAMIENTOS(ID) on update cascade;

--alter table public.MOVIMIENTOS_INTERNOS_MP add constraint CK_MIMP_IdBascula check (SELECT MOVIMIENTOS_INTERNOS_MP.IdBascula IN (SELECT ID from EQUIPAMIENTOS where EQUIPAMIENTOS.Tipo_Equipamiento='Bascula'));
--NO SE PUEDEN REALIZAR SUB-CONSULTAS EN RESTRICCION CHECK. AMERITA TRIGGERS OBLIGATORIAMENTE.

--INSERCION DE TUPLAS EN LA BD

--ORDENES DE PRODUCCION



--LOTES


--ORDENES DE COMPRA

--insert into ORDENES_COMPRA (Fecha_Origen, Unidad_De_Medida, Costo_De_Compra_PorUnidad, Estado, IdProveedor, IdOrdenProduccion) values ('04/09/2019', 'Tonelada',400, 'Concretado', 1, 1);
--insert into ORDENES_COMPRA (Fecha_Origen, Unidad_De_Medida, Costo_De_Compra_PorUnidad, Estado, IdProveedor, IdOrdenProduccion) values ('04/09/2019', 'Tonelada',400, 'Concretado', 1, 1);

--YERBA CANCHADA VERDE
--insert into LOTES (Estado, Tipo_Lote, Cantidad, Unidad_De_Medida, IdOrdenCompra) values ('Activo', 'YCV', 180, 'Tonelada', 1);
--insert into LOTES (Estado, Tipo_Lote, Cantidad, Unidad_De_Medida, IdOrdenCompra) values ('Activo', 'YCE', 180, 'Tonelada', 1);


--MODULO DE ESTACIONAMIENTO Y MOLIENDA

--CREACIÓN DE TABLAS



create table TRANSFORMACIONES (
	ID SERIAL,
	Estado varchar(30),
	Fecha_Origen date,
	primary key(ID));

create table MOLIENDAS (
	IdTransformacion int,
	Sector varchar(30),
	Turno varchar(30),
	primary key (IdTransformacion));

create table ESTACIONAMIENTOS (
	IdTransformacion int,
	Fecha_extraccion date,
	primary key (IdTransformacion));

create table DETALLES_TRANSFORMACION (
	ID SERIAL,
	cantidad_Utilizada int,
	Unidad_De_Medida varchar(30),
	primary key(ID));

--CLAVES FORANEAS


--TRANSFORMACIONES
alter table TRANSFORMACIONES add column IdEquipamiento int NOT NULL;
alter table public.TRANSFORMACIONES add constraint FK_EQUIPAMIENTOS_ID foreign key (IdEquipamiento) references EQUIPAMIENTOS(ID) on update cascade;


--ESTACIONAMIENTOS

	alter table public.ESTACIONAMIENTOS add constraint FK_TRANSFORMACIONES_ID foreign key (IdTransformacion) references TRANSFORMACIONES(ID) on update cascade;

--MOLIENDAS

	alter table public.MOLIENDAS add constraint FK_TRANSFORMACIONES_ID foreign key (IdTransformacion) references TRANSFORMACIONES(ID) on update cascade;

--DETALLES DE TRANSFORMACION

alter table DETALLES_TRANSFORMACION add column IdTransformacion int NOT NULL;
alter table public.DETALLES_TRANSFORMACION add constraint FK_TRANSFORMACIONES_ID foreign key (IdTransformacion) references TRANSFORMACIONES(ID) on update cascade;

alter table DETALLES_TRANSFORMACION add column IdLote int NOT NULL;
alter table public.DETALLES_TRANSFORMACION add constraint FK_LOTES_ID foreign key (IdLote) references LOTES(ID) on update cascade;



--RESTRICCIONES DE CHEQUEO

--EQUIPAMIENTOS

alter table public.EQUIPAMIENTOS  add column IdBascula int;
alter table public.EQUIPAMIENTOS add constraint FK_BASCULAS_ID foreign key (IdBascula) references EQUIPAMIENTOS(ID) on update cascade;


alter table public.EQUIPAMIENTOS 
	add constraint CK_TIPO_EQUIPAMIENTO 
	check (Tipo_Equipamiento = 'Molino' OR Tipo_Equipamiento = 'Deposito' OR Tipo_Equipamiento = 'Camara de Estacionamiento' OR Tipo_Equipamiento = 'Bascula');
	
alter table public.EQUIPAMIENTOS 
	add constraint CK_UNIDAD_MEDIDA
	check (Unidad_De_Medida = 'Tonelada' OR Unidad_De_Medida = 'Kilogramo');

alter table public.ORDENES_COMPRA 
	add constraint CK_UNIDAD_MEDIDA
	check (Unidad_De_Medida = 'Tonelada' OR Unidad_De_Medida = 'Kilogramo');

alter table public.LOTES
	add constraint CK_UNIDAD_MEDIDA
	check (Unidad_De_Medida = 'Tonelada' OR Unidad_De_Medida = 'Kilogramo');
	
alter table public.ORDENES_PRODUCCION 
	add constraint CK_UNIDAD_MEDIDA
	check (Unidad_De_Medida = 'Tonelada' OR Unidad_De_Medida = 'Kilogramo');

--PROCEDIMIENTO DE ALMACENADO PARA INSERCION DE DEPOSITOS.


--TRIGGERS
--Verificacion de que los Movimientos interno de materia prima referencian ids de Basculas

CREATE OR REPLACE FUNCTION Funcion_Trigger_VerificarEquipamiento() returns TRIGGER as
$BODY$
	Begin
		IF NOT (SELECT NEW.IdBascula IN (SELECT ID from EQUIPAMIENTOS where (EQUIPAMIENTOS.Tipo_Equipamiento='Bascula'))) THEN 
			RAISE EXCEPTION 'Se esta referenciando un Equipamiento que no es una bascula';
			RETURN null;
		END IF;
RETURN NEW;
	End;
$BODY$
language plpgsql;

CREATE TRIGGER insercion_MIMP BEFORE INSERT OR UPDATE ON MOVIMIENTOS_INTERNOS_MP
	FOR EACH ROW EXECUTE PROCEDURE Funcion_Trigger_VerificarEquipamiento();




--v1.10

--APLICAR ESTO A LO QUE SIGUE




--TABLA DE USUARIOS


	
	


CREATE OR REPLACE FUNCTION Funcion_Trigger_CuentaDeUsuario() returns TRIGGER as
$BODY$
DECLARE aux varchar;
	BEGIN
		aux = 'c'||NEW.DNI;
		execute 'CREATE ROLE '||aux||' LOGIN PASSWORD '||$$'$$||NEW.DNI||$$'$$||' IN ROLE '||NEW.Rol;
		UPDATE USUARIOS set rol_asociado= (SELECT oid from pg_roles where (rolname = aux)) where ID = NEW.ID;
		UPDATE USUARIOS set Nombre_Usuario = aux WHERE ID = NEW.ID;
		RETURN NULL;
	END;
$BODY$
language plpgsql;

CREATE TRIGGER creacion_cuentas AFTER INSERT ON USUARIOS
	FOR EACH ROW EXECUTE PROCEDURE Funcion_Trigger_CuentaDeUsuario();

CREATE OR REPLACE FUNCTION Funcion_Trigger_eliminarCuenta_Usuarios() returns TRIGGER as
$body$
	DECLARE AUX varchar;
	BEGIN
		aux = 'c'||OLD.DNI;
		if (SELECT rolname from pg_roles where ROLNAME=aux) IS NOT NULL then
			execute 'DROP ROLE '||aux;
		end if;
		RETURN NULL;
	END;
$body$
language plpgsql;

CREATE TRIGGER borrado_cuentas after DELETE on USUARIOS
	FOR EACH ROW EXECUTE PROCEDURE Funcion_Trigger_eliminarCuenta_Usuarios();
	
--INSERCION DE ALGUNOS USUARIOS






DO
$BODY$
DECLARE AUX varchar;
begin
	AUX = 'gerenteareaproduccion';
	if (SELECT rolname from pg_roles where ROLNAME=AUX) IS NOT NULL then
		execute 'REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM '||AUX;
		execute 'REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM '|| AUX;
		execute 'REVOKE ALL PRIVILEGES ON SCHEMA PUBLIC FROM '||AUX;
		execute 'REVOKE CONNECT ON DATABASE postgres FROM '|| AUX;	
		execute 'DROP ROLE IF EXISTS '||AUX;
	end if;
	
	AUX = 'operadorbalanza';
	if (SELECT rolname from pg_roles where ROLNAME=AUX) IS NOT NULL then
		execute 'REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM '||AUX;
		execute 'REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM '|| AUX;
		execute 'REVOKE ALL PRIVILEGES ON SCHEMA PUBLIC FROM '||AUX;
		execute 'REVOKE CONNECT ON DATABASE postgres FROM '|| AUX;	
		execute 'DROP ROLE IF EXISTS '||AUX;
	end if;	
	
	AUX = 'recuperador';
	if (SELECT rolname from pg_roles where ROLNAME=AUX) IS NOT NULL then
		execute 'REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM '||AUX;
		execute 'REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM '|| AUX;
		execute 'REVOKE ALL PRIVILEGES ON SCHEMA PUBLIC FROM '||AUX;
		execute 'REVOKE CONNECT ON DATABASE postgres FROM '|| AUX;	
		execute 'DROP ROLE IF EXISTS '||AUX;
	end if;		
end;
$BODY$
language plpgsql;




-- ESTO TIENE QUE ESTAR SIEMPRE AL FINAL, PORQUE SINO TENGO QUE ADHERIR MANUALMENTE LAS TABLAS CREADAS POSTERIORMENTE.
CREATE ROLE recuperador LOGIN PASSWORD 'recuperador';
GRANT SELECT ON ALL TABLES IN SCHEMA public TO recuperador;
GRANT USAGE ON SCHEMA public TO recuperador;
--GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO recuperador;
GRANT CONNECT ON DATABASE postgres TO recuperador;

CREATE ROLE GerenteAreaProduccion NOLOGIN;
GRANT SELECT, UPDATE, INSERT ON ALL TABLES IN SCHEMA public TO GerenteAreaProduccion;
GRANT USAGE ON SCHEMA public TO GerenteAreaProduccion;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO GerenteAreaProduccion;
GRANT CONNECT ON DATABASE postgres TO GerenteAreaProduccion;

CREATE ROLE OperadorBalanza NOLOGIN;
GRANT INSERT, UPDATE ON MOVIMIENTOS_INTERNOS_MP to OperadorBalanza;
GRANT USAGE ON SCHEMA public TO OperadorBalanza;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO GerenteAreaProduccion;
GRANT INSERT, UPDATE ON LOTES to OperadorBalanza;
GRANT CONNECT ON DATABASE postgres TO OperadorBalanza;





CREATE OR REPLACE FUNCTION sp_perteneceARol(usuario varchar, rol varchar) returns boolean as
$BODY$
DECLARE retorno boolean;
DECLARE oid_rol_actual oid;
DECLARE oid_rol_perteneciente oid;
BEGIN
	retorno = false;
	oid_rol_actual = (SELECT oid from pg_roles where rolname = (usuario));
	oid_rol_perteneciente = (SELECT oid from pg_roles where rolname=rol);
	if oid_rol_perteneciente IS NOT NULL then
		if (oid_rol_actual in (SELECT member from pg_auth_members where roleid=oid_rol_perteneciente)) then
			retorno = true;
		end if;
	end if;
	return retorno;
END;
$BODY$
language plpgsql SECURITY DEFINER;

INSERT INTO USUARIOS (Nombre, Apellido, DNI, Rol, Estado) VALUES ('Juan Jose', 'Bolano', 39, 'gerenteareaproduccion', 'Activo');
INSERT INTO USUARIOS (Nombre, Apellido, DNI, Rol, Estado) VALUES ('Fede', 'Bazyluk', 40, 'operadorbalanza', 'Activo');
INSERT INTO USUARIOS (Nombre, Apellido, DNI, Rol, Estado) VALUES ('Fabian', 'Enrique', 41, 'gerenteareaproduccion', 'Activo');




/*
DO
$BODY$
begin
	RAISE NOTICE '%',sp_perteneceARol('c39','gerenteareaproduccion');
end;
$BODY$
*/




/*
REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM GerenteAreaProduccion;
REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM GerenteAreaProduccion;
REVOKE ALL PRILEGES ON SCHEMA PUBLIC FROM GerenteAreaProduccion;

REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM OperadorBalanza;
REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM OperadorBalanza;

REVOKE CONNECT ON DATABASE postgres FROM GerenteAreaProduccion;
REVOKE CONNECT ON DATABASE postgres FROM OperadorBalanza;
DROP ROLE IF EXISTS c39;
DROP ROLE IF EXISTS GerenteAreaProduccion;
DROP ROLE IF EXISTS OperadorBalanza;

CREATE ROLE GerenteAreaProduccion NOLOGIN;
GRANT SELECT, UPDATE, INSERT ON ALL TABLES IN SCHEMA public TO GerenteAreaProduccion;
GRANT USAGE ON SCHEMA public TO GerenteAreaProduccion;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO GerenteAreaProduccion;
GRANT CONNECT ON DATABASE postgres TO GerenteAreaProduccion;

CREATE ROLE OperadorBalanza NOLOGIN;
GRANT INSERT, UPDATE ON MOVIMIENTOS_INTERNOS_MP to OperadorBalanza;
GRANT USAGE ON SCHEMA public TO OperadorBalanza;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO GerenteAreaProduccion;
GRANT INSERT, UPDATE ON LOTES to OperadorBalanza;
GRANT CONNECT ON DATABASE postgres TO OperadorBalanza;

*/



--AUDITORIA

--Insercion y Actualizacion de movimientos

create table AUDITORIA_ORDENES_PRODUCCION  (
	ID SERIAL,
	ID_Evento integer NOT NULL,
	Fecha Date,
	Cantidad_A_Producir_Antiguo float,
	Cantidad_A_Producir_Nuevo float,
	Unidad_De_Medida_Antiguo varchar(30),
	Unidad_De_Medida_Nuevo varchar(30),
	Fecha_Origen_Antiguo date,
	Fecha_Origen_Nuevo date, 
	Fecha_Entrega_Antiguo date, 
	Fecha_Entrega_Nuevo date, 
	Estado_Antiguo varchar(30),
	Estado_Nuevo varchar(30),
	Descripcion_Antiguo varchar(250),
	Descripcion_Nuevo varchar(250),
	primary key(ID));
	

alter table public.AUDITORIA_ORDENES_PRODUCCION add column IdUsuario int NOT NULL;
alter table public.AUDITORIA_ORDENES_PRODUCCION add constraint FK_USUARIOS_ID foreign key (IdUsuario) references USUARIOS(ID) on update cascade on delete cascade;	
	
	
	

CREATE OR REPLACE FUNCTION public.funcion_trigger_Auditoria_Ordenes_Produccion()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    VOLATILE
    COST 100
AS 
$BODY$
	Begin
		IF (cast(TG_TABLE_NAME as varchar) = 'ordenes_produccion') then
			IF (cast (TG_OP as varchar)='INSERT') then
				insert into public.AUDITORIA_ORDENES_PRODUCCION (
					IdUsuario,
					ID_Evento,
					Fecha,
					Cantidad_A_Producir_Nuevo,
					Unidad_De_Medida_Nuevo,
					Fecha_Origen_Nuevo, 
					Fecha_Entrega_Nuevo, 
					Estado_Nuevo,
					Descripcion_Nuevo) 
				values (
					new.IdUsuario,
					new.Id_Evento,
					(SELECT CURRENT_DATE),
					new.Cantidad_A_Producir,
					new.Unidad_De_Medida,
					new.Fecha_Origen,
					new.Fecha_Entrega,
					new.Estado,
					NEW.Descripcion
					);
			ELSIF (cast(TG_OP as varchar)='UPDATE') then
				insert into public.AUDITORIA_ORDENES_PRODUCCION (
					IdUsuario,
					ID_Evento,
					Fecha,
					Cantidad_A_Producir_Antiguo,
					Cantidad_A_Producir_Nuevo,
					Unidad_De_Medida_Antiguo,
					Unidad_De_Medida_Nuevo,
					Fecha_Origen_Antiguo,
					Fecha_Origen_Nuevo, 
					Fecha_Entrega_Antiguo,
					Fecha_Entrega_Nuevo, 
					Estado_Antiguo,
					Estado_Nuevo,
					Descripcion_Antiguo,
					Descripcion_Nuevo) 
				values (
					new.IdUsuario,
					new.Id_Evento,
					(SELECT CURRENT_DATE),
					old.Cantidad_A_Producir,
					new.Cantidad_A_Producir,
					old.Unidad_De_Medida,
					new.Unidad_De_Medida,
					old.Fecha_Origen,
					new.Fecha_Origen,
					old.Fecha_Entrega,
					new.Fecha_Entrega,
					old.Estado,
					new.Estado,
					old.Descripcion,
					NEW.Descripcion
					);
			END IF;
		END IF;
		RETURN NULL;
	End
$BODY$ SECURITY DEFINER;

CREATE TRIGGER trigger_auditoria_ordenes_produccion AFTER INSERT OR UPDATE ON ORDENES_PRODUCCION 
	FOR EACH ROW EXECUTE PROCEDURE funcion_trigger_Auditoria_Ordenes_Produccion();
	
insert into ORDENES_PRODUCCION (idUsuario, Cantidad_A_Producir, Unidad_De_Medida, Fecha_Origen, Fecha_Entrega, Estado) values (1, 400, 'Tonelada', '01/09/2019', '04/01/2020', 'Regular');
insert into ORDENES_PRODUCCION (idUsuario, Cantidad_A_Producir, Unidad_De_Medida, Fecha_Origen, Fecha_Entrega, Estado) values (1, 400, 'Tonelada', '01/09/2019', '04/01/2020', 'Regular');
insert into ORDENES_PRODUCCION (idUsuario, Cantidad_A_Producir, Unidad_De_Medida, Fecha_Origen, Fecha_Entrega, Estado) values (3, 300, 'Tonelada', '01/09/2019', '04/01/2020', 'Regular');
insert into ORDENES_PRODUCCION (idUsuario, Cantidad_A_Producir, Unidad_De_Medida, Fecha_Origen, Fecha_Entrega, Estado) values (3, 300, 'Tonelada', '01/09/2019', '04/01/2020', 'Regular');

--PAIS

insert into PAISES (Nombre, Estado) values ('ARGENTINA', 'Activo');
insert into PROVINCIAS (Nombre, Estado, IdPais) values ('MISIONES', 'Activo', 1);
insert into LOCALIDADES (Nombre, Estado, IdProvincia, Codigo_Postal) values ('APOSTOLES', 'Activo', 1, 'N3350XAD');
insert into LOCALIDADES (Nombre, Estado, IdProvincia, Codigo_Postal) values ('POSADAS', 'Activo', 1, '3300');

--PROVEEDORES

insert into PROVEEDORES (Razon_Social, CUIT, Estado, idLocalidad) values ('Cosechero Feliz', '20-54655814-02', 'Activo', 1);
insert into PROVEEDORES (Razon_Social, CUIT, Estado, idLocalidad) values ('Siembra soleada', '20-54655815-02', 'Activo', 2);	