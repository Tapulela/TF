--V1.4:
--	Ahora la bascula es una variante mas de equipamiento.
--	Los equipamientos referencian una bascula.
--	Agregada restriccion de chequeo de idBascula en Movimientos internos de Materia prima: Se verifica que se referencia a un equipamiento de tipo bascula.
--	Agregado a ordenes de compra informacion de la cantidad a comprar, costo por unidad y unidad de medida.
--	Agregado fecha de Origen a la tabla de Movimientos.
-- 	Agregado estado a Movimiento. Puede ser:
--		Listo para Transformarse: Lo que se registro en este movimiento es para una transformacion en el equipamiento asociado.
--		Utilizado: Ya se registro una transformacion sobre ese movimiento
--		De Almacenamiento temporal: Lo que se registro en este movimiento no sera utilizado en este equipamiento. Será trasladado posteriormente.
--		Trasladado: El almacenamiento temporal terminó y ese lote fue trasladado.
--	Agregado etiquetas a los lotes
--v1.6
--	Removido la clave foranea de lote padre de los lotes.
--v1.7
--	Removido la clave foranea de Orden de compra con lotes
--	Agregado la clave foranea de lotes hacia orden de compra.
--	Agregado la clave foranea de lotes hacia Equipamiento. (Un lote esta en un momento dado en un equipamiento)
--	CAMBIADO CUIL POR CUIT en proveedores
--	Ahora tambien es un campo unico la razon social en proveedores
--	Agregado campo de descripcion a las ordenes de producción.

--v1.8
--	REMOCION DE TODAS LAS CLAVES FORANEAS REDUNDANTES.
--	En la base de datos: La menor cantidad de referencias posibles.
--	En la aplicación: La mayor cantidad de referencias posibles.
--	Removido clave foranea de lote hacia orden de produccion
-- 	Removido clave foranea de lote hacia equipamiento. (El lote reside en el equipamiento sobre el que equipamiento destino del ultimo movimiento registrado.

--v1.9
--	Agregado de tablas de Pais provincia y Localidad
--	Agregado referencia de proveedor a localidad

--v1.10
--	Adicion de ROLES


--PRIMERO SE DEBEN ELIMINAR TODOS LOS USUARIOS
DELETE from usuarios;

--Borrar toda la base de datos, para luego poder realizar todas las definiciones con los contadores incrementales en 0.
DROP SCHEMA public CASCADE;
CREATE SCHEMA public;

--ESTABLECER EL FORMATO DD/MM/AAAA:
SET DATESTYLE TO 'European';

--ROLES


	
--AGREGADO DEL ROL AL QUE PERTENECE CADA USUARIO

--FUNCION DE CONVERSION DE UNIDADES DE MEDIDA

--Conversion de Peso
CREATE OR REPLACE FUNCTION convertirUnidadPeso(unidad_De_Medida_Inicial varchar(30), unidad_De_Medida_Final varchar(30), peso float) returns float as
$BODY$
BEGIN
	CASE
		When (unidad_De_Medida_Inicial='Tonelada') AND (unidad_De_Medida_Final = 'Kilogramo') THEN	
			RETURN peso*1000;
		When (unidad_De_Medida_Inicial='Kilogramo') AND (unidad_De_Medida_Final = 'Tonelada') THEN	
			RETURN peso/1000;
		ELSE
			RETURN peso;
	END CASE;
END;
$BODY$
language plpgsql;


--CREAR LAS TABLAS

create table PAISES (
	ID SERIAL, 
	Nombre varchar(100) UNIQUE NOT NULL,
	Estado varchar(30) NOT NULL,
	primary key(ID));

create table PROVINCIAS (
	ID SERIAL, 
	Nombre varchar(100) NOT NULL,
	Estado varchar(30) NOT NULL,
	primary key(ID));
	
create table LOCALIDADES (
	ID SERIAL, 
	Nombre varchar(100) NOT NULL,
	Codigo_Postal varchar(10) NOT NULL,
	Estado varchar(30) NOT NULL,
	primary key(ID));	

create table ORDENES_PRODUCCION (
	ID SERIAL, 
	Cantidad_A_Producir float, 
	Unidad_De_Medida varchar(30), 
	Fecha_Origen date, 
	Fecha_Entrega date, 
	Estado varchar(30),
	Descripcion varchar(250),
	primary key(ID));

create table ORDENES_COMPRA (
	ID SERIAL,
	Fecha_Origen date NOT NULL,
	Cantidad float NOT NULL,
	Unidad_De_Medida varchar(30) NOT NULL,
	Costo_De_Compra_PorUnidad float NOT NULL,
	Estado varchar(30) NOT NULL,
	primary key(ID));

create table PROVEEDORES (
	ID SERIAL,
	Razon_Social varchar(60), 
	CUIT varchar(30) NOT NULL, 
	Estado varchar(30), 
	primary key (ID), 
	UNIQUE(CUIT),
	UNIQUE(Razon_Social));

create table LOTES (
	ID SERIAL,
	Tipo_Lote varchar(60) NOT NULL,
	Etiqueta varchar(60),
	Estado varchar(30),
	Cantidad int,
	Unidad_De_Medida varchar(30),
	Fecha_Adquisicion date,
	primary key(ID));

create table MOVIMIENTOS_INTERNOS_MP(
	ID SERIAL,
	Fecha_Origen TIMESTAMPTZ NOT NULL,
	Fecha_Entrada TIMESTAMPTZ NOT NULL,
	Fecha_Salida TIMESTAMPTZ NOT NULL,
	Tipo_Unidad_Transporte varchar(60) NOT NULL,
	cantidad_Unidades int NOT NULL,
	Unidad_De_Medida_Peso varchar(30) NOT NULL,
	Peso_Entrada float NOT NULL,
	Peso_Salida float NOT NULL,
	N_Hoja_Ruta varchar(50) NOT NULL,
	N_Remito varchar(50) NOT NULL,
	N_Precinto varchar(50) NOT NULL,
	Nombre_Conductor varchar(100) NOT NULL,
	Patente_Chasis varchar(30) NOT NULL,
	Patente_Acoplado varchar(30) NOT NULL,

	Estado varchar(30) NOT NULL,
	primary key(ID));


create table EQUIPAMIENTOS (
	ID SERIAL,
	Nombre varchar(60) UNIQUE NOT NULL,
	Tipo_Equipamiento varchar(60) NOT NULL,
	Direccion varchar(60) NOT NULL,
	Fecha_Adquisicion date NOT NULL,
	Fecha_Ultimo_Mantenimiento date,
	Capacidad_Maxima float NOT NULL,
	Unidad_De_Medida varchar(30) NOT NULL,
	Duracion_Maxima_Estacionamiento float,
	Estado varchar(30),
	primary key(ID));

--INSERCION CLAVES FORANEAS

--PAIS, PROVINCIA Y LOCALIDAD

alter table PROVINCIAS add column IdPais int NOT NULL;
alter table public.PROVINCIAS add constraint FK_PAISES_ID foreign key (IdPais) references PAISES(ID) on update cascade;

 alter table PROVINCIAS
   add constraint UQ_PROVINCIA_PAIS
   unique (Nombre, IdPais);

alter table LOCALIDADES add column IdProvincia int NOT NULL;
alter table public.LOCALIDADES add constraint FK_PROVINCIAS_ID foreign key (IdProvincia) references PROVINCIAS(ID) on update cascade;

 alter table LOCALIDADES
   add constraint UQ_LOCALIDAD_PROVINCIA
   unique (Nombre, IdProvincia);
--PROVEEDORES

alter table PROVEEDORES add column IdLocalidad int NOT NULL;
alter table public.PROVEEDORES add constraint FK_LOCALIDADES_ID foreign key (IdLocalidad) references LOCALIDADES(ID) on update cascade;


--ORDENES DE COMPRA


--alter table ORDENES_COMPRA add column IdLote int NOT NULL; --DEBERIA SER UNIQUE?
--alter table public.ORDENES_COMPRA add constraint FK_LOTES_ID foreign key (IdLote) references LOTES(ID) on update cascade;

alter table ORDENES_COMPRA add column IdProveedor int;
alter table public.ORDENES_COMPRA add constraint FK_PROVEEDORES_ID foreign key (IdProveedor) references PROVEEDORES(ID) on update cascade;

alter table ORDENES_COMPRA add column IdOrdenProduccion int NOT NULL;
alter table public.ORDENES_COMPRA add constraint FK_ORDENES_PRODUCCION_ID foreign key (IdOrdenProduccion) references ORDENES_PRODUCCION(ID) on update cascade;

--LOTES


alter table LOTES add column IdOrdenCompra int NOT NULL; --NO PUEDE SER NULL.
alter table public.LOTES add constraint FK_ORDENES_COMPRA_ID foreign key (IdOrdenCompra) references ORDENES_COMPRA(ID) on update cascade;



--MOVIMIENTOS_INTERNOS_MP

alter table MOVIMIENTOS_INTERNOS_MP add column IdLote int NOT NULL;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_LOTES_ID foreign key (IdLote) references LOTES(ID) on update cascade;

alter table MOVIMIENTOS_INTERNOS_MP add column IdBascula int NOT NULL;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_BASCULAS_ID foreign key (IdBascula) references EQUIPAMIENTOS(ID) on update cascade;

alter table MOVIMIENTOS_INTERNOS_MP add column IdEquipamientoOrigen int;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_ORIGEN_ID foreign key (IdEquipamientoOrigen) references EQUIPAMIENTOS(ID) on update cascade;

alter table MOVIMIENTOS_INTERNOS_MP add column IdEquipamientoDestino int;
alter table public.MOVIMIENTOS_INTERNOS_MP add constraint FK_DESTINO_ID foreign key (IdEquipamientoDestino) references EQUIPAMIENTOS(ID) on update cascade;
--alter table public.MOVIMIENTOS_INTERNOS_MP add constraint CK_MIMP_IdBascula check (SELECT MOVIMIENTOS_INTERNOS_MP.IdBascula IN (SELECT ID from EQUIPAMIENTOS where EQUIPAMIENTOS.Tipo_Equipamiento='Bascula'));
--NO SE PUEDEN REALIZAR SUB-CONSULTAS EN RESTRICCION CHECK. AMERITA TRIGGERS OBLIGATORIAMENTE.

--INSERCION DE TUPLAS EN LA BD

--ORDENES DE PRODUCCION

insert into ORDENES_PRODUCCION (Cantidad_A_Producir, Unidad_De_Medida, Fecha_Origen, Fecha_Entrega, Estado) values (400, 'Tonelada', '01/09/2019', '04/01/2020', 'Regular');
insert into ORDENES_PRODUCCION (Cantidad_A_Producir, Unidad_De_Medida, Fecha_Origen, Fecha_Entrega, Estado) values (400, 'Tonelada', '01/09/2019', '04/01/2020', 'Regular');

--PAIS

insert into PAISES (Nombre, Estado) values ('ARGENTINA', 'Activo');
insert into PROVINCIAS (Nombre, Estado, IdPais) values ('MISIONES', 'Activo', 1);
insert into LOCALIDADES (Nombre, Estado, IdProvincia, Codigo_Postal) values ('APOSTOLES', 'Activo', 1, 'N3350XAD');
insert into LOCALIDADES (Nombre, Estado, IdProvincia, Codigo_Postal) values ('POSADAS', 'Activo', 1, '3300');

--PROVEEDORES

insert into PROVEEDORES (Razon_Social, CUIT, Estado, idLocalidad) values ('Cosechero Feliz', '20-54655814-02', 'Activo', 1);
insert into PROVEEDORES (Razon_Social, CUIT, Estado, idLocalidad) values ('Siembra soleada', '20-54655815-02', 'Activo', 2);

--LOTES


--ORDENES DE COMPRA

--insert into ORDENES_COMPRA (Fecha_Origen, Unidad_De_Medida, Costo_De_Compra_PorUnidad, Estado, IdProveedor, IdOrdenProduccion) values ('04/09/2019', 'Tonelada',400, 'Concretado', 1, 1);
--insert into ORDENES_COMPRA (Fecha_Origen, Unidad_De_Medida, Costo_De_Compra_PorUnidad, Estado, IdProveedor, IdOrdenProduccion) values ('04/09/2019', 'Tonelada',400, 'Concretado', 1, 1);

--YERBA CANCHADA VERDE
--insert into LOTES (Estado, Tipo_Lote, Cantidad, Unidad_De_Medida, IdOrdenCompra) values ('Activo', 'YCV', 180, 'Tonelada', 1);
--insert into LOTES (Estado, Tipo_Lote, Cantidad, Unidad_De_Medida, IdOrdenCompra) values ('Activo', 'YCE', 180, 'Tonelada', 1);


--MODULO DE ESTACIONAMIENTO Y MOLIENDA

--CREACIÓN DE TABLAS



create table TRANSFORMACIONES (
	ID SERIAL,
	Estado varchar(30),
	Fecha_Origen date,
	primary key(ID));

create table MOLIENDAS (
	IdTransformacion int,
	Sector varchar(30),
	Turno varchar(30),
	primary key (IdTransformacion));

create table ESTACIONAMIENTOS (
	IdTransformacion int,
	Fecha_extraccion date,
	primary key (IdTransformacion));

create table DETALLES_TRANSFORMACION (
	ID SERIAL,
	cantidad_Utilizada int,
	Unidad_De_Medida varchar(30),
	primary key(ID));

--CLAVES FORANEAS


--TRANSFORMACIONES
alter table TRANSFORMACIONES add column IdEquipamiento int NOT NULL;
alter table public.TRANSFORMACIONES add constraint FK_EQUIPAMIENTOS_ID foreign key (IdEquipamiento) references EQUIPAMIENTOS(ID) on update cascade;


--ESTACIONAMIENTOS

	alter table public.ESTACIONAMIENTOS add constraint FK_TRANSFORMACIONES_ID foreign key (IdTransformacion) references TRANSFORMACIONES(ID) on update cascade;

--MOLIENDAS

	alter table public.MOLIENDAS add constraint FK_TRANSFORMACIONES_ID foreign key (IdTransformacion) references TRANSFORMACIONES(ID) on update cascade;

--DETALLES DE TRANSFORMACION

alter table DETALLES_TRANSFORMACION add column IdTransformacion int NOT NULL;
alter table public.DETALLES_TRANSFORMACION add constraint FK_TRANSFORMACIONES_ID foreign key (IdTransformacion) references TRANSFORMACIONES(ID) on update cascade;

alter table DETALLES_TRANSFORMACION add column IdLote int NOT NULL;
alter table public.DETALLES_TRANSFORMACION add constraint FK_LOTES_ID foreign key (IdLote) references LOTES(ID) on update cascade;



--RESTRICCIONES DE CHEQUEO

--EQUIPAMIENTOS

alter table public.EQUIPAMIENTOS  add column IdBascula int;
alter table public.EQUIPAMIENTOS add constraint FK_BASCULAS_ID foreign key (IdBascula) references EQUIPAMIENTOS(ID) on update cascade;


alter table public.EQUIPAMIENTOS 
	add constraint CK_TIPO_EQUIPAMIENTO 
	check (Tipo_Equipamiento = 'Molino' OR Tipo_Equipamiento = 'Deposito' OR Tipo_Equipamiento = 'Camara de Estacionamiento' OR Tipo_Equipamiento = 'Bascula');
	
alter table public.EQUIPAMIENTOS 
	add constraint CK_UNIDAD_MEDIDA
	check (Unidad_De_Medida = 'Tonelada' OR Unidad_De_Medida = 'Kilogramo');

alter table public.ORDENES_COMPRA 
	add constraint CK_UNIDAD_MEDIDA
	check (Unidad_De_Medida = 'Tonelada' OR Unidad_De_Medida = 'Kilogramo');

alter table public.LOTES
	add constraint CK_UNIDAD_MEDIDA
	check (Unidad_De_Medida = 'Tonelada' OR Unidad_De_Medida = 'Kilogramo');
	
alter table public.ORDENES_PRODUCCION 
	add constraint CK_UNIDAD_MEDIDA
	check (Unidad_De_Medida = 'Tonelada' OR Unidad_De_Medida = 'Kilogramo');

--PROCEDIMIENTO DE ALMACENADO PARA INSERCION DE DEPOSITOS.


--TRIGGERS
--Verificacion de que los Movimientos interno de materia prima referencian ids de Basculas

CREATE OR REPLACE FUNCTION Funcion_Trigger_VerificarEquipamiento() returns TRIGGER as
$BODY$
	Begin
		IF NOT (SELECT NEW.IdBascula IN (SELECT ID from EQUIPAMIENTOS where (EQUIPAMIENTOS.Tipo_Equipamiento='Bascula'))) THEN 
			RAISE EXCEPTION 'Se esta referenciando un Equipamiento que no es una bascula';
			RETURN null;
		END IF;
RETURN NEW;
	End;
$BODY$
language plpgsql;

CREATE TRIGGER insercion_MIMP BEFORE INSERT OR UPDATE ON MOVIMIENTOS_INTERNOS_MP
	FOR EACH ROW EXECUTE PROCEDURE Funcion_Trigger_VerificarEquipamiento();




--v1.10

--APLICAR ESTO A LO QUE SIGUE




--TABLA DE USUARIOS

create table USUARIOS (
	ID SERIAL, 
	Nombre varchar(100) NOT NULL,
	Apellido varchar(100) NOT NULL,
	DNI varchar(100) UNIQUE NOT NULL,
	Estado varchar(30) NOT NULL,
	Rol varchar(100),
	primary key(ID));
	
alter table USUARIOS add column rol_asociado oid;
	
	


CREATE OR REPLACE FUNCTION Funcion_Trigger_CuentaDeUsuario() returns TRIGGER as
$BODY$
DECLARE aux varchar;
	BEGIN
		aux = 'c'||NEW.DNI;
		execute 'CREATE ROLE '||aux||' LOGIN PASSWORD '||$$'$$||NEW.DNI||$$'$$||' IN ROLE '||NEW.Rol;
		UPDATE USUARIOS set rol_asociado= (SELECT oid from pg_roles where (rolname = aux)) where DNI = NEW.DNI;
		RETURN NULL;
	END;
$BODY$
language plpgsql;

CREATE TRIGGER creacion_cuentas AFTER INSERT ON USUARIOS
	FOR EACH ROW EXECUTE PROCEDURE Funcion_Trigger_CuentaDeUsuario();

CREATE OR REPLACE FUNCTION Funcion_Trigger_eliminarCuenta_Usuarios() returns TRIGGER as
$body$
	DECLARE AUX varchar;
	BEGIN
		aux = 'c'||OLD.DNI;
		if (SELECT rolname from pg_roles where ROLNAME=aux) IS NOT NULL then
			execute 'DROP ROLE '||aux;
		end if;
		RETURN NULL;
	END;
$body$
language plpgsql;

CREATE TRIGGER borrado_cuentas after DELETE on USUARIOS
	FOR EACH ROW EXECUTE PROCEDURE Funcion_Trigger_eliminarCuenta_Usuarios();
	
--INSERCION DE ALGUNOS USUARIOS




INSERT INTO USUARIOS (Nombre, Apellido, DNI, Rol, Estado) VALUES ('Juanjo', 'Bolano', 39, 'GerenteAreaProduccion', 'Activo');
INSERT INTO USUARIOS (Nombre, Apellido, DNI, Rol, Estado) VALUES ('Fede', 'Bolano', 40, 'OperadorBalanza', 'Activo');

DO
$BODY$
DECLARE AUX varchar;
begin
	AUX = 'gerenteareaproduccion';
	if (SELECT rolname from pg_roles where ROLNAME=AUX) IS NOT NULL then
		execute 'REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM '||AUX;
		execute 'REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM '|| AUX;
		execute 'REVOKE ALL PRIVILEGES ON SCHEMA PUBLIC FROM '||AUX;
		execute 'REVOKE CONNECT ON DATABASE postgres FROM '|| AUX;	
		execute 'DROP ROLE IF EXISTS '||AUX;
	end if;
	
	AUX = 'operadorbalanza';
	if (SELECT rolname from pg_roles where ROLNAME=AUX) IS NOT NULL then
		execute 'REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM '||AUX;
		execute 'REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM '|| AUX;
		execute 'REVOKE ALL PRIVILEGES ON SCHEMA PUBLIC FROM '||AUX;
		execute 'REVOKE CONNECT ON DATABASE postgres FROM '|| AUX;	
		execute 'DROP ROLE IF EXISTS '||AUX;
	end if;	
	
	AUX = 'recuperador';
	if (SELECT rolname from pg_roles where ROLNAME=AUX) IS NOT NULL then
		execute 'REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM '||AUX;
		execute 'REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM '|| AUX;
		execute 'REVOKE ALL PRIVILEGES ON SCHEMA PUBLIC FROM '||AUX;
		execute 'REVOKE CONNECT ON DATABASE postgres FROM '|| AUX;	
		execute 'DROP ROLE IF EXISTS '||AUX;
	end if;		
end;
$BODY$
language plpgsql;




-- ESTO TIENE QUE ESTAR SIEMPRE AL FINAL, PORQUE SINO TENGO QUE ADHERIR MANUALMENTE LAS TABLAS CREADAS POSTERIORMENTE.
CREATE ROLE recuperador LOGIN PASSWORD 'recuperador';
GRANT SELECT ON ALL TABLES IN SCHEMA public TO recuperador;
GRANT USAGE ON SCHEMA public TO recuperador;
--GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO recuperador;
GRANT CONNECT ON DATABASE postgres TO recuperador;

CREATE ROLE GerenteAreaProduccion NOLOGIN;
GRANT SELECT, UPDATE, INSERT ON ALL TABLES IN SCHEMA public TO GerenteAreaProduccion;
GRANT USAGE ON SCHEMA public TO GerenteAreaProduccion;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO GerenteAreaProduccion;
GRANT CONNECT ON DATABASE postgres TO GerenteAreaProduccion;

CREATE ROLE OperadorBalanza NOLOGIN;
GRANT INSERT, UPDATE ON MOVIMIENTOS_INTERNOS_MP to OperadorBalanza;
GRANT USAGE ON SCHEMA public TO OperadorBalanza;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO GerenteAreaProduccion;
GRANT INSERT, UPDATE ON LOTES to OperadorBalanza;
GRANT CONNECT ON DATABASE postgres TO OperadorBalanza;

/*
REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM GerenteAreaProduccion;
REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM GerenteAreaProduccion;
REVOKE ALL PRILEGES ON SCHEMA PUBLIC FROM GerenteAreaProduccion;

REVOKE ALL PRIVILEGES ON ALL TABLES in schema public FROM OperadorBalanza;
REVOKE ALL PRIVILEGES ON ALL SEQUENCES in schema public FROM OperadorBalanza;

REVOKE CONNECT ON DATABASE postgres FROM GerenteAreaProduccion;
REVOKE CONNECT ON DATABASE postgres FROM OperadorBalanza;
DROP ROLE IF EXISTS c39;
DROP ROLE IF EXISTS GerenteAreaProduccion;
DROP ROLE IF EXISTS OperadorBalanza;

CREATE ROLE GerenteAreaProduccion NOLOGIN;
GRANT SELECT, UPDATE, INSERT ON ALL TABLES IN SCHEMA public TO GerenteAreaProduccion;
GRANT USAGE ON SCHEMA public TO GerenteAreaProduccion;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO GerenteAreaProduccion;
GRANT CONNECT ON DATABASE postgres TO GerenteAreaProduccion;

CREATE ROLE OperadorBalanza NOLOGIN;
GRANT INSERT, UPDATE ON MOVIMIENTOS_INTERNOS_MP to OperadorBalanza;
GRANT USAGE ON SCHEMA public TO OperadorBalanza;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO GerenteAreaProduccion;
GRANT INSERT, UPDATE ON LOTES to OperadorBalanza;
GRANT CONNECT ON DATABASE postgres TO OperadorBalanza;

*/